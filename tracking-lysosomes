% Linda 02 July 2018 - code not finalized

clear all, warning off, close all
set(0,'DefaultFigureWindowStyle','docked')
addpath('../functions')
addpath('/Applications/Fiji.app/scripts')

zp=0; %1- plot all figures
file_path_tracks = 'movie10_cropped_timecropped_tracks_15022018.xml';
clipZ = true;     % Remove Z coordinates, if you know you can.
scaleT = true;       % Use physical time for T.
tracks = importTrackMateTracks(file_path_tracks, clipZ, scaleT);
n_tracks = numel( tracks );
%tracks = importTrackMateTracks(file_path_tracks, clipZ, scaleT);
fprintf('Found %d tracks in the file.\n', n_tracks)
exposure = input('Exposure (seconds per frame): ');
min_nPoints = input('Minimum number of points in tracks (13 if 0.1ms/fr, 7 if 0.2ms/fr, 5 if 0.3ms/fr): ');
n_frames = input('Number of frames for smoothing (same as min_nPoints): ');
new_X = input('x coordinate from cell center: ');  % coodinate from cell center taken from ImageJ
new_Y = input('y coordinate from cell center: ');

% To make a figure of the trackmate trajectories
%figure(1)      % Plots the tracks as is from ImageJ Trackmate
%hold on
%c = jet(n_tracks);
%n_tracks = numel( tracks );
%for s = 1 : n_tracks
%x = tracks{s}(:, 2);
%y = tracks{s}(:, 3);
%plot(x, y, '.-', 'Color', c(s, :))
%end
%axis equal

% To save new track coodinates zeroed from the cell center
new_tracks = [];
for s = 1 : n_tracks
    if numel(tracks{s}(:, 1)) > min_nPoints  % Select only tracks with minimum number of points
        new_tracks1 = tracks{s}(:, 1);
        new_tracks2 = tracks{s}(:, 2) - new_X;
        new_tracks3 = tracks{s}(:, 3) - new_Y;
        new_tracks_final=[new_tracks1,new_tracks2,new_tracks3];
        new_tracks{s} = new_tracks_final;
    end
end
new_tracks = new_tracks';
tracks = new_tracks;
tracks(cellfun('isempty', tracks)) = [];   % getting rid of all cells without values
n_tracks = numel( tracks );        % number of tracks

%Plots the tracks with cell center as (0, 0)
figure(2)
hold on
c = jet(n_tracks);
n_tracks = numel( tracks );
for s = 1 : n_tracks
x = tracks{s}(:, 2);
y = tracks{s}(:, 3);
plot(x, y, '.-', 'Color', c(s, :))
end
axis equal

% Looking at start (x1,y1) and end point(x2,y2) of the trajectory
% If absolute values of x2 > x1 or y2 > y1, then the trajectory is outward,
% away from cell center
%outward_tracks = [];
%inward_tracks = [];
%for s = 1 : n_tracks
%if abs(new_tracks{s}(end, 2)) > abs(new_tracks{s}(1,2)) | abs(new_tracks{s}(end, 3)) > abs(new_tracks{s}(1,3))
%outward_tracks{s} = new_tracks{s};
%else
%inward_tracks{s} = new_tracks{s};
%end
%end
%outward_tracks = outward_tracks(~cellfun('isempty', outward_tracks));
%inward_tracks = inward_tracks(~cellfun('isempty', inward_tracks));
%outward_tracks = outward_tracks';
%inward_tracks = inward_tracks';

% Plots the tracks based on directionality
%figure(3)
%hold on
%number = numel( outward_tracks );
%for s = 1 : number
%x = outward_tracks{s}(:, 2);
%y = outward_tracks{s}(:, 3);
%plot(x, y, '.-', 'Color', 'b')
%end
%number2 = numel( inward_tracks );
%for s = 1 : number2
%x = inward_tracks{s}(:, 2);
%y = inward_tracks{s}(:, 3);
%plot(x, y, '.-', 'Color', 'r')
%end
%axis equal


% Radius of gyration Rg for each track
all_x = [];
all_y = [];
mean_x_cum = zeros(n_tracks, 1);
mean_y_cum = zeros(n_tracks, 1);
Rg = zeros(n_tracks, 1);
for s = 1 : n_tracks
    % x and y coordinates of every spot in a track
    all_x{s} = tracks{s}(:, 2);
    all_y{s} = tracks{s}(:, 3);
    mean_x = mean(all_x{s}(:, 1));
    mean_y = mean(all_y{s}(:, 1));
    % mean of x and y coordinates for each track
    mean_x_cum(s) = mean_x;
    mean_y_cum(s) = mean_y;
    % calculation of a = (x-X)^2 and b = (y-Y)^2 for each x and y
    for x_value = 1 : numel(all_x{s}(:, 1))
        a = ((all_x{s}(x_value, 1))-mean_x).^2;
        b = ((all_y{s}(x_value, 1))-mean_y).^2;
        c = a+b;
        all_a{s}(x_value) = a;
        all_b{s}(x_value) = b;
        all_c{s}(x_value) = c;   % c values then are all summed for a track
    end
    Rg(s) = sqrt((1/numel(all_x{s}(:, 1)))*sum(all_c{s}(1, :))); % Rg for a track
end
% You can make a histogram of hist(Rg) to see the distribution for Rg's of a cell

% Select all events that are mostly stationary/diffusive
% -- find their # and their project their localization
% Doing this the simple way - looking at start point vs. end point of track
% Do this in Image J, after tracking, filter based on "Track Displacement"
% and "Number of spots in Track"


% Select only peripheral tracks to be analyzed, based on radius of gyration
% (i.e based on a fixed distance from the cell center)


% Fitting the polynomial to generate MT coordinates
poly_coeff = [];     % generates the coefficients for each track
poly_eval_y = [];    % poly_eval_y are the y value estimates for each x value, i.e. MT coord
for s = 1 : n_tracks
    diff_x = (diff(tracks{s}(:, 2)));
    diff_y = (diff(tracks{s}(:, 3)));
    track_vector{s} = [0, 0; diff_x, diff_y];
    
    % Drawing the MT for each track with polynomial fit
    [x_tracks{s},x_ind]=unique(tracks{s}(:,2));
    y_tracks{s}=tracks{s}(x_ind,3);
    poly_coeff{s} = polyfit(x_tracks{s}, y_tracks{s}, 2);
    poly_eval_y{s} = polyval(poly_coeff{s}, x_tracks{s});
    
    diff_x_tracks{s} = diff(x_tracks{s});
    diff_poly_eval_y{s} = diff(poly_eval_y{s});
    mt_vector{s} = [0, 0; diff_x_tracks{s}, diff_poly_eval_y{s}];
    mt_coords{s} = [x_tracks{s}, poly_eval_y{s}];
end

poly_coeff = poly_coeff';
x_tracks = x_tracks';
poly_eval_y = poly_eval_y';
diff_poly_eval_y = diff_poly_eval_y';
diff_x_tracks = diff_x_tracks';
track_vector = track_vector';
mt_vector = mt_vector';
mt_coords = mt_coords';

% Fit (interpolate) the tracks to the MT coordinates
% Calculate metrics
delp=zeros(1,numel(tracks{s}(:, 2)));
delp_off=zeros(1,numel(tracks{s}(:, 2)));
%for s = 1:10; disp('Analyze tracks 1-10');
    for s=1 : n_tracks
    if numel(mt_vector{s}(:, 1)) > 3     
        fit_vector{s}(:,1)=interp1(mt_coords{s}(:,1), mt_vector{s}(:, 1) ,tracks{s}(:, 2),'pchip');
        fit_vector{s}(:,2)=interp1(mt_coords{s}(:,1), mt_vector{s}(:, 2), tracks{s}(:, 3),'pchip');
        fit_norm{s}=repmat(sqrt(sum(fit_vector{s}.^2,2)),1,2);
        fit_vector_norm{s}=fit_vector{s}./fit_norm{s}; %normalize
        delp=zeros(1,numel(tracks{s}(:, 2)));
        delp_off=zeros(1,numel(tracks{s}(:, 2)));
        for kv=1:numel(tracks{s}(:, 2))
            delp(kv)=track_vector{s}(kv,:)*fit_vector_norm{s}(kv,:)';
            delp_off(kv)=track_vector{s}(kv,:)*(fit_vector_norm{s}(kv,:)*[0,1;-1,0])';
        end
        position{s}=cumsum(delp); % displacement of the particle, should look like kymograph
        position_smooth{s}=sgolayfilt(position{s},1,n_frames); % smooth the kymograph track so less noise, 1st order, smoothing over 5 frames
        position_off{s}=cumsum(delp_off);
        diff_position{s}=diff(position_smooth{s});
        diff_position{s}(isnan(diff_position{s})) = [];
        abs_diff_position{s} = abs(diff_position{s});
        
        cum_run_length(s) = sum(abs_diff_position{s});
        cum_mean_velocity(s) = mean(abs_diff_position{s}./exposure);
        cum_binding_time(s) = numel(diff_position{s})*exposure;   % of the whole track
        
        % Run between reversals
        delp_smooth{s} = diff(position_smooth{s});
        delp1{s}=delp_smooth{s}(1:(end-1));  %First value to the second last value
        delp2{s}=delp_smooth{s}(2:end);  %Second value to the last value
        jrev_all{s}=find(sign(delp1{s})~=sign(delp2{s})); %finds the indices of all reversals
        jrev_all{s} = jrev_all{s} + 1;
        pos_rev_all{s}=position{s}(jrev_all{s}); % the position at those indices, the positions of all rev
        run_bw_reversal_all{s}=diff(pos_rev_all{s}); % run lengths between each reversal
        j_rev_keep{s} = find(abs(run_bw_reversal_all{s})> 0); % indices
        jrev{s} = jrev_all{s}(j_rev_keep{s});  % the value at those indices above
        
        jkr{s} = [1, jrev{s}, numel(tracks{s}(:, 2))];
        pos_rev{s} = position_smooth{s}(jkr{s});
        run_bw_reversal{s} = diff(pos_rev{s});       % runs between reversals for each track
        
        time = tracks{s}(:, 1);
        time_rev{s} = time(jkr{s});
        time_bw_reversal{s} = diff(time_rev{s});     % times between reversals for each track
        
        velocity_bw_reversal{s} = run_bw_reversal{s}./time_bw_reversal{s}';  % velocities between reversals for each track
        
        n_rev(s) = numel(jkr{s});                            % number of reversals for each track
        rev_rate(s) = n_rev(s)/(time(end)-time(1));    % rate of reversal for each track
        
        if zp==1
           figure, plot(tracks{s}(:,2), tracks{s}(:,3),'b.-')
           hold on, plot(mt_coords{s}(:,1), mt_coords{s}(:,2),'c.-')
           xlabel('x'), ylabel('y')
           
           figure, subplot(211), plot(time,position{s}), xlabel('t'), ylabel('position')
           subplot(212), plot(time, position_off{s}), xlabel('t'), ylabel('position_{off}')
       
        end
    end
end

% Separate plus-ended and minus-ended runs between reversals
n_runs = numel(run_bw_reversal);
for s = 1: n_runs
    % threshold: min length of runs between reversals
    run_bw_rev_threshold_index{s} = find(abs(run_bw_reversal{s}) > 0.00);
    run_bw_rev_threshold{s} = run_bw_reversal{s}(run_bw_rev_threshold_index{s});
    time_bw_rev_threshold{s} = time_bw_reversal{s}(run_bw_rev_threshold_index{s});
    time_bw_rev_threshold{s} = time_bw_rev_threshold{s}';
    velocity_bw_rev_threshold{s} = velocity_bw_reversal{s}(run_bw_rev_threshold_index{s});
    for e = 1: numel(time_bw_rev_threshold{s})
        if run_bw_rev_threshold{s}(1, e) > 0
            run_bw_rev_pos{s}(1,e) = run_bw_rev_threshold{s}(1, e);
            time_bw_rev_pos{s}(1,e) = time_bw_rev_threshold{s}(1, e);
            velocity_bw_rev_pos{s}(1,e) = velocity_bw_rev_threshold{s}(1, e);
        else
            run_bw_rev_neg{s}(1,e) = run_bw_rev_threshold{s}(1, e);
            time_bw_rev_neg{s}(1,e) = time_bw_rev_threshold{s}(1, e);
            velocity_bw_rev_neg{s}(1,e) = velocity_bw_rev_threshold{s}(1, e);
        end
    end
    
end
% The following calculates the sum of plus-ended and minus-ended runs
% within each track
n_pos = numel(run_bw_rev_pos);
n_neg = numel(run_bw_rev_neg);
for s = 1: n_pos
    sum_run_pos(s) = sum(run_bw_rev_pos{s});
    sum_time_pos(s) = sum(time_bw_rev_pos{s});
    mean_velocity_pos(s) = mean(velocity_bw_rev_pos{s});
end
for s = 1: n_neg
    sum_run_neg(s) = sum(run_bw_rev_neg{s});
    sum_time_neg(s) = sum(time_bw_rev_neg{s});
    mean_velocity_neg(s) = mean(velocity_bw_rev_neg{s});
end
sum_run_pos(sum_run_pos == 0) = NaN;
sum_run_pos(isnan(sum_run_pos)) = [];
sum_run_neg(sum_run_neg == 0) = NaN;
sum_run_neg(isnan(sum_run_neg)) = [];
sum_run_neg = abs(sum_run_neg);

sum_time_pos(sum_time_pos == 0) = NaN;
sum_time_pos(isnan(sum_time_pos)) = [];
sum_time_neg(sum_time_neg == 0) = NaN;
sum_time_neg(isnan(sum_time_neg)) = [];

mean_velocity_pos(mean_velocity_pos == 0) = NaN;
mean_velocity_pos(isnan(mean_velocity_pos)) = [];
mean_velocity_neg(mean_velocity_neg == 0) = NaN;
mean_velocity_neg(isnan(mean_velocity_neg)) = [];
mean_velocity_neg = abs(mean_velocity_neg);

cum_run_length(cum_run_length == 0) = NaN;   % zero values become NaN
cum_run_length(isnan(cum_run_length)) = [];  % remove NaN from matrix

cum_mean_velocity(cum_mean_velocity == 0) = NaN;
cum_mean_velocity(isnan(cum_mean_velocity)) = [];

cum_binding_time(cum_binding_time == 0) = NaN;
cum_binding_time(isnan(cum_binding_time)) = [];




% To make a figure of the microtubules projected from the track fitting
figure(4)
hold on
n_mt = numel(mt_coords);
d = jet(n_mt);
for s = 1 : n_tracks
    x_mt = mt_coords{s}(:, 1);
    y_mt = mt_coords{s}(:, 2);
    plot(x_mt, y_mt, '.-', 'Color', d(s, :))
end
axis equal


% Saving desired metrics into matlab workspace table: put them in ' '
% save([file_path_tracks'_results.mat'],'Rg','...')

% Plot the trajectory and polynomial fit (the MT) for a single track, here track1
%track1_x = tracks{1}(:, 2);    % x coordinates of track 1
%track1_y = tracks{1}(:, 3);    % y coordinates of track 1
%figure(1), hold on
%plot(track1_x, track1_y, 'r-')       % plot track 1
%plot(track1_x, track1_y, '+') % add this line to see spots as +'s
%plot(x_tracks{1}, poly_eval_y{1}, 'k--')          % plot the MT

% IGNORE THE FOLLOWING
% ____________________________________________
% Calculates run lengths of tracks (raw)
% cum_length = zeros(n_tracks, 1);
% for s = 1 : n_tracks
% track_length = 0;
% for c = 1 : numel(diff_x)
% distance(c) = sqrt((diff_x(c)).^2 + (diff_y(c)).^2);
% track_length = distance(c) + track_length;
% end
% raw_cum_length(s) = track_length;    % the raw run lengths of each track cumulated
% end

% OR    ** Check if this method of calculating raw run length is like above
% cum_length = zeros(n_tracks, 1);
% for s = 1 : n_tracks
% diff_x = (diff(tracks{s}(:, 2)));
% diff_y = (diff(tracks{s}(:, 3)));
% track_length = sum(sqrt((abs(diff_x)).^2 + (abs(diff_y)).^2));
% cum_length(s) = track_length;
% end

% Calculates binding time of tracks (raw)
%cum_binding = zeros(n_tracks, 1);
%for s = 1 : n_tracks
%    binding_time = tracks{s}(end, 1);
%    cum_binding(s) = binding_time; %Cumulates binding time of each track
%end

% Calculates instantaneous velocity of tracks (raw)
%cum_inst_velocity = zeros(n_tracks, 1);
%for s = 1 : n_tracks
%diff_x = (diff(tracks{s}(:, 2)));
%diff_y = (diff(tracks{s}(:, 3)));
%track_length = sqrt((abs(diff_x)).^2 + (abs(diff_y)).^2);
%velocity = track_length/exposure;
%inst_velocity = mean(velocity);
%cum_inst_velocity(s) = inst_velocity;
%end

